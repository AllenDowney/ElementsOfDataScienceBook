\hypertarget{variables-and-values}{%
\chapter{Variables and Values}\label{variables-and-values}}

Python provides tools for working with many kinds of data, including
numbers, words, dates, times, and locations (latitude and longitude).

In this chapter, we'll start with numbers and mathematical operations.
In the next chapter, we'll work with dates, times, and locations.

\hypertarget{numbers}{%
\section{Numbers}\label{numbers}}

Python can work with several types of numbers,
but the two most common are

\begin{itemize}
\item
  \passthrough{\lstinline!int!}, which represents integer values like
  \passthrough{\lstinline!3!}
\item
  \passthrough{\lstinline!float!}, which represents numbers that have a
  fraction part, like \passthrough{\lstinline!3.14159!}
\end{itemize}
\passthrough{\lstinline!float!} is short for ``floating-point,'' which
is the name of the way these numbers are stored.

Most often, we use \passthrough{\lstinline!int!} to represent counts and
\passthrough{\lstinline!float!} to represent measurements.

\hypertarget{arithmetic}{%
\section{Arithmetic}\label{arithmetic}}

Python provides operators that perform arithmetic. The operators that
perform addition and subtraction are \passthrough{\lstinline!+!} and
\passthrough{\lstinline!-!}:

\begin{lstlisting}[]
3 + 2 - 1
(@\dashfill@)
@@@4@@@
\end{lstlisting}
In this example, the first line shows the input, which is Python code; the second line shows the output, which is the result of the calculation.

The \passthrough{\lstinline!*!} operator performs multiplication: 

\begin{lstlisting}[]
2 * 3
(@\dashfill@)
@@@6@@@
\end{lstlisting}
The \passthrough{\lstinline!/!} operator performs division:
\begin{lstlisting}[]
2 / 3
(@\dashfill@)
@@@0.6666666666666666@@@
\end{lstlisting}
And the \passthrough{\lstinline!**!} operator is for exponentiation:

\begin{lstlisting}[]
2**3
(@\dashfill@)
@@@8@@@
\end{lstlisting}

Unlike math notation, Python does not allow ``implicit multiplication.''
For example, in math notation, if you write \(3 (2 + 1)\), that's
understood to be the same as \(3 \times (2+ 1)\). Python doesn't allow
that notation. If you want to multiply, you have to use the
\passthrough{\lstinline!*!} operator.

The arithmetic operators follow the rules of precedence you might have
learned as PEMDAS, which stands for parentheses before exponentiation before multiplication and division before addition and subtraction.

So in this expression, the multiplication happens first:

\begin{lstlisting}[]
1 + 2 * 3
(@\dashfill@)
@@@7@@@
\end{lstlisting}

If that's not what you want, you can
use parentheses to make the order of operations explicit:

\begin{lstlisting}[]
(1 + 2) * 3
(@\dashfill@)
@@@9@@@
\end{lstlisting}

\hypertarget{math-functions}{%
\section{Math Functions}\label{math-functions}}

Python provides functions that compute all the usual mathematical
functions, like \passthrough{\lstinline!sin!} and
\passthrough{\lstinline!cos!}, \passthrough{\lstinline!exp!} and
\passthrough{\lstinline!log!}. However, they are not part of Python
itself; they are in a \emph{library}, which is a collection of
functions that supplement the Python language.

Python has several libraries that provide math functions; we'll use NumPy, which stands for ``Numerical Python''
and is pronounced ``num pie.'' Before you can use a library, you have to
\emph{import} it, like this:

\begin{lstlisting}[]
import numpy as np
\end{lstlisting}

It's conventional to import \passthrough{\lstinline!numpy!} as
\passthrough{\lstinline!np!}, which means we can refer to it by the
short name \passthrough{\lstinline!np!} rather than the longer name
\passthrough{\lstinline!numpy!}. Names like this are case-sensitive,
which means that \passthrough{\lstinline!numpy!} is not the same as
\passthrough{\lstinline!NumPy!}. Even though the name of the library
is NumPy, when we import it we have to call it
\passthrough{\lstinline!numpy!}.

But assuming we import \passthrough{\lstinline!np!} correctly, we can
use it to read the value \passthrough{\lstinline!pi!}, which is an
approximation of the mathematical constant \(\pi\):

\begin{lstlisting}[]
np.pi
(@\dashfill@)
@@@3.141592653589793@@@
\end{lstlisting}

The result is a \passthrough{\lstinline!float!} with 16 digits. As you
might know, we can't represent \(\pi\) with a finite number of digits,
so this result is only approximate.

NumPy provides \passthrough{\lstinline!log!}, which computes the natural
logarithm:

\begin{lstlisting}[]
np.log(100)
(@\dashfill@)
@@@4.605170185988092@@@
\end{lstlisting}

NumPy also provides \passthrough{\lstinline!exp!}, which raises the
constant \passthrough{\lstinline!e!} to a power:

\begin{lstlisting}[]
np.exp(1)
(@\dashfill@)
@@@2.718281828459045@@@
\end{lstlisting}


As this example shows, floating-point numbers are finite approximations,
which means they don't always behave like math.

As another example, let's see what happens when you add up
\passthrough{\lstinline!0.1!} three times:

\begin{lstlisting}[]
0.1 + 0.1 + 0.1
(@\dashfill@)
@@@0.30000000000000004@@@
\end{lstlisting}
The result is close to \passthrough{\lstinline!0.3!}, but not exact.


\hypertarget{variables}{%
\section{Variables}\label{variables}}

A \emph{variable} is a name that refers to a value. The following
statement assigns the value \passthrough{\lstinline!5!} to a variable
named \passthrough{\lstinline!x!}:

\begin{lstlisting}[]
x = 5
\end{lstlisting}

The variable we just created has the name \passthrough{\lstinline!x!}
and the value \passthrough{\lstinline!5!}.

If we use \passthrough{\lstinline!x!} as part of an arithmetic
operation, it represents the value \passthrough{\lstinline!5!}. For example:

\begin{lstlisting}[]
x + 1
(@\dashfill@)
@@@6@@@
\end{lstlisting}

\begin{lstlisting}[]
x**2
(@\dashfill@)
@@@25@@@
\end{lstlisting}

We can also use \passthrough{\lstinline!x!} with
\passthrough{\lstinline!numpy!} functions:

\begin{lstlisting}[]
np.exp(x)
(@\dashfill@)
@@@148.4131591025766@@@
\end{lstlisting}
Notice that the result from \passthrough{\lstinline!exp!} is a
\passthrough{\lstinline!float!}, even though the value of
\passthrough{\lstinline!x!} is an \passthrough{\lstinline!int!}.

If you have not programmed before, one of the things
you have to get used to is that programming languages are picky about
details. Natural languages, like English, and semi-formal languages,
like math notation, are more forgiving.

As an example, in math notation parentheses and square brackets mean
the same thing, so you can write

\[\sin (\omega t)\]
or

\[\sin [\omega t]\]
Either one is fine. And you can leave out the parentheses altogether, as
long as the meaning is clear:

\[\sin \omega t\]

In Python, every character counts. For example, the following are all
different, and only the first one works:

\begin{lstlisting}
np.exp(x)
np.Exp(x)
np.exp[x]
np.exp x
\end{lstlisting}

While you are learning, I encourage you to make mistakes on purpose to
see what goes wrong. Read the error messages carefully. Sometimes they
are helpful and tell you exactly what's wrong. Other times they can be
misleading. But if you have seen the message before, you might remember
some likely causes.

\hypertarget{calculating-with-variables}{%
\section{Calculating with Variables}\label{calculating-with-variables}}

Now we'll use variables to solve a problem involving compound interest.
It might not be the most exciting example, but it uses everything we
have done so far, and it reviews exponentiation and logarithms, which we
are going to need.

If we start with a principal sum, \(P\), and earn compounded interest,
the total accumulated value, \(V\), at the end of time \(t\) is:

\[V=P\left(1+{\frac {r}{n}}\right)^{nt}\]
where \(r\) is the annual interest rate and \(n\) is the compounding
frequency.

For example, if we deposit \$2,100 in a bank paying an annual interest
rate of 3.4\% compounded quarterly, we can compute the balance after seven
years by defining these variables:

\begin{lstlisting}[]
P = 2100
r = 0.034
n = 4
t = 7
\end{lstlisting}

We compute the total accumulated value like this:

\begin{lstlisting}[]
P * (1 + r/n)**(n*t)
(@\dashfill@)
@@@2661.6108980682593@@@
\end{lstlisting}

\hypertarget{summary}{%
\section{Summary}\label{summary}}

This chapter introduces variables, which are names that refer to values,
and two kinds of values: integers and floating-point numbers.

It presents mathematical operators, like \passthrough{\lstinline!+!} for
addition and \passthrough{\lstinline!*!} for multiplication, and
mathematical functions like \passthrough{\lstinline!log!} for logarithms
and \passthrough{\lstinline!exp!} for raising
\passthrough{\lstinline!e!} to a power.

In the next chapter, we'll see additional data types for representing
letters and words, dates and times, and latitude and longitude.
\hypertarget{exercises}{%
\section{Exercises}\label{exercises}}

\begin{listhead}
\item [1.1]
\label{exercise-1}
Write a Python expression that raises
\passthrough{\lstinline!1+2!} to the power
\passthrough{\lstinline!3*4!}. The answer should be
\passthrough{\lstinline!531441!}.
\item[1.2]\label{exercise-2}
Use these functions to confirm the mathematical
identity \(\log(e^x) = x\), which should be true for any value of \(x\).

With floating-point values, this identity should work for values of
\(x\) between $-$700 and 700. What happens when you try it with larger and
smaller values?
\item[1.3]\label{exercise-3}
Search the NumPy documentation to find the function
that computes square roots, and use it to compute a floating-point
approximation of the golden ratio:

\[\phi = \frac{1 + \sqrt{5}}{2}\]
Hint: the result should be close to \passthrough{\lstinline!1.618!}.
\item[1.4]\label{exercise-4}
Building on the example of calculating compound interest in this chapter, start
with a principal of \$2,100 in a bank paying an annual interest
rate of 3.4\% with interest compounded twice per year, so the compounding frequency  \passthrough{\lstinline!n = 2!}. What
would the total value be after seven years? Hint: we expect the answer to be
a bit less than the value generated by the example in the chapter, which rounds to 2661.61.

\item[1.5]\label{exercise-5}Using the principal and interest from Exercise 1.4, if interest is compounded continuously, the value
after time \(t\) is given by the formula

\[V=P~e^{rt}\]
Translate this equation into Python and use it to compute the value of the
investment. Hint: we
expect the answer to be a bit more than the previous answer.
